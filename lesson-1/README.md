# Lesson 1. Node js вступление

- Node.js. NPM
- Базовые модули Node.js
- Работа с файловой системой. модуль fs
- Прямой доступ к файлам. переменная path
- Создание Web-сервера на Node.js
- Организация кода в Node.js
- Nodemon, мониторинг изменений в файлах Node.js
- Роутинг

## Node.js

Node.js — это опенсорсная кроссплатформенная среда выполнения для JavaScript, которая работает на серверах. С момента выпуска этой платформы в 2009 году она стала чрезвычайно популярной и в наши дни играет весьма важную роль в области веб-разработки. Если считать показателем популярности число звёзд, которые собрал некий проект на GitHub, то Node.js, у которого более 50000 звёзд, это очень и очень популярный проект.

Платформа Node.js построена на базе JavaScript движка V8 от Google, который используется в браузере Google Chrome. Данная платформа, в основном, используется для создания веб-серверов, однако сфера её применения этим не ограничивается.

Рассмотрим основные особенности Node.js.

▍Скорость

Одной из основных привлекательных особенностей Node.js является скорость. JavaScript-код, выполняемый в среде Node.js, может быть в два раза быстрее, чем код, написанный на компилируемых языках, вроде C или Java, и на порядки быстрее интерпретируемых языков наподобие Python или Ruby. Причиной подобного является неблокирующая архитектура платформы, а конкретные результаты зависят от используемых тестов производительности, но, в целом, Node.js — это очень быстрая платформа.

▍Простота

Платформа Node.js проста в освоении и использовании. На самом деле, она прямо-таки очень проста, особенно это заметно в сравнении с некоторыми другими серверными платформами.

▍JavaScript

В среде Node.js выполняется код, написанный на JavaScript. Это означает, что миллионы фронтенд-разработчиков, которые уже пользуются JavaScript в браузере, могут писать и серверный, и клиентский код на одном и том же языке программирования без необходимости изучать совершенно новый инструмент для перехода к серверной разработке.
В браузере и на сервере используются одинаковые концепции языка. Кроме того, в Node.js можно оперативно переходить на использование новых стандартов ECMAScript по мере их реализации на платформе. Для этого не нужно ждать до тех пор, пока пользователи обновят браузеры, так как Node.js — это серверная среда, которую полностью контролирует разработчик. В результате новые возможности языка оказываются доступными при установке поддерживающей их версии Node.js.

▍Движок V8

В основе Node.js, помимо других решений, лежит опенсорсный JavaScript-движок V8 от Google, применяемый в браузере Google Chrome и в других браузерах. Это означает, что Node.js пользуется наработками тысяч инженеров, которые сделали среду выполнения JavaScript Chrome невероятно быстрой и продолжают работать в направлении совершенствования V8.

▍Асинхронность

В традиционных языках программирования (C, Java, Python, PHP) все инструкции, по умолчанию, являются блокирующими, если только разработчик явным образом не позаботится об асинхронном выполнении кода. В результате если, например, в такой среде, произвести сетевой запрос для загрузки некоего JSON-кода, выполнение потока, из которого сделан запрос, будет приостановлено до тех пор, пока не завершится получение и обработка ответа.

JavaScript значительно упрощает написание асинхронного и неблокирующего кода с использованием единственного потока, функций обратного вызова (коллбэков) и подхода к разработке, основанной на событиях. Каждый раз, когда нам нужно выполнить тяжёлую операцию, мы передаём соответствующему механизму коллбэк, который будет вызван сразу после завершения этой операции. В результате, для того чтобы программа продолжила работу, ждать результатов выполнения подобных операций не нужно.

Для этого был придуман механизм [event loop](https://www.youtube.com/watch?v=8cV4ZvHXQL4)

Подобный механизм возник в браузерах. Мы не можем позволить себе ждать, скажем, окончания выполнения AJAX-запроса, не имея при этом возможности реагировать на действия пользователя, например, на щелчки по кнопкам. Для того чтобы пользователям было удобно работать с веб-страницами, всё, и загрузка данных из сети, и обработка нажатия на кнопки, должно происходить одновременно, в режиме реального времени.

Если вы создавали когда-нибудь обработчик события нажатия на кнопку, то вы уже пользовались методиками асинхронного программирования.

Асинхронные механизмы позволяют единственному Node.js-серверу одновременно обрабатывать тысячи подключений, не нагружая при этом программиста задачами по управлению потоками и по организации параллельного выполнения кода. Подобные вещи часто являются источниками ошибок.

Node.js предоставляет разработчику неблокирующие базовые механизмы ввода вывода, и, в целом, библиотеки, использующиеся в среде Node.js, написаны с использованием неблокирующих парадигм. Это делает блокирующее поведение кода скорее исключением, чем нормой.

Когда Node.js нужно выполнить операцию ввода-вывода, вроде загрузки данных из сети, доступа к базе данных или к файловой системе, вместо того, чтобы заблокировать ожиданием результатов такой операции главный поток, Node.js инициирует её выполнение и продолжает заниматься другими делами до тех пор, пока результаты выполнения этой операции не будут получены.

[Node js вступление](https://habr.com/company/ruvds/blog/422893/)

## NPM

`npm` это пакетный менеджер, который работает на node js.

С помощью npm можно устанавливать пакеты (библиотеки) локально или глобально. В локальном режиме пакеты устанавливаются в каталог node_modules родительского каталога.  

Пакеты можно ставить локально ```npm install <package-name>``` и глобально локально ```npm install <package-name> -g```

[Введение в пакетный менеджер](http://prgssr.ru/development/vvedenie-v-paketnyj-menedzher-npm-dlya-nachinayushih.html)

## Базовые модули Node.js

### Подключение скриптов: require
    
В браузере, когда мы хотим добавить еще один скрипт на страницу мы используем, как правило тег: <script></script>. В Node.JS для этой же цели мы используем специальную команду: «require» и работает она совсем, совсем по другому.

#### Пример

Файл 1
```
const module = {
    app: 'myApp' 
};

module.exports = module

```

Файл 2
```
cosnt myModule = require('./module');

console.log(myModule);
```

### Переменная «global»
Что если мы хотим все таки глобальные переменные? Например есть такие объекты как скажем «logger» или «База данных» или какой то глобальный объект приложения, которые мы хотим, чтобы были доступны явно и везде. Без всяких там экспортов, просто потому что они, такие вот важные. На самом деле в Node.JS есть концепция глобальных переменных, но вместо объекта «window», который используется в браузере, используется объект «global».  И то, что мы пишем в этот объект «global». Работает он так же как и window в браузере.


### Http модуль

В node js есть модуль HTTP. Он позволяет передавать данные по http протоколу, создавать серверы, получать запросы, отправлять ответы и записывать информацию в них.

Модуль http крайне низкоуровневый: создание сложного веб-приложения с использованием вышеприведенного фрагмента кода очень трудоемко. Именно по этой причине мы обычно выбираем фреймворки для работы над нашими проектами. Есть множество фреймворков, вот самые популярные:

- [express](https://expressjs.com/)
- [hapi](https://hapijs.com/)
- [koa](https://koajs.com/)
- [restify](http://restify.com/)

Пример

```
const server = http.createServer(requestHandler)
```
  

### FS (file system) модуль

В Node.JS, для работы с файлами существует модуль «FS» и в нем есть множество функций для самых различных операций с файлами и директориями. 

#### Базовые операции

- Read files
- Create files
- Update files
- Delete files
- Rename files

[Ссылка на документацию](https://js-node.ru/site/article?id=23)

Есть одинаковые методы как `fs.copyFile()` и `fs.copyFileSync()`

Первое просто имя, второе со словом Sync. Слово Sync означает синхронно.Если я например вызову fs.readFile(file[, options], callback), то он сначала прочитает файл полностью, а потом вызовет callback. А fs.readFileSync(file[, options]) затормозит выполнение процесса пока файл не будет прочитан. По этому, как правило синхронный вызов используют либо в консольных утилитах, либо на стадии инициализации сервера, когда такие тормоза допустимы. А асинхронный вызов, в тех случаях когда хочется, чтоб полноценно работал событийный цикл, то есть, чтоб Node.JS не ждал пока диск сработает, медленно и файл прочитается.

[Ссылка на статью с примерами](https://www.w3schools.com/nodejs/nodejs_filesystem.asp)

### path модуль

Модуль path предоставляет утилиты для работы с путями к файлам и директориям.
С помощью нее мы можем взять файл который нам нужен и передав его в другой модуль (например fs) сделать нужные операции.


Пример:
```
path.join('/foo', 'bar', 'baz/asdf', 'quux', '..')
// Возвращает: '/foo/bar/baz/asdf'

path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')
// если текущая рабочая директория /home/myself/node,
// Возвращает '/home/myself/node/wwwroot/static_files/gif/image.gif'

```

[Все методы модуля](https://js-node.ru/site/article?id=30)

#### Ключевое слово __dirname

В Node.js, `__dirname` всегда находится каталог, в котором находится текущий исполняемый script. Поэтому, если вы набрали `__dirname` в `/d1/d2/myscript.js`, значение будет `/d1/d2`.


## Создание Web-сервера на Node.js

Вот пример создания простого сервера на nod.js

```
const http = require('http');
const port = 3000;

const requestHandler = (request, response) => {
    console.log(request.url);
    response.end('Hello Node.js Server!');
};

const server = http.createServer(requestHandler);

server.listen(port, (err) => {
    if (err) {
        return console.log('something bad happened', err)
    }
    console.log(`server is listening on ${port}`)
});

```

Теперь мы можем отправить запрос на адрес `http://localhost:3000/` и получить ответ от сервера.

[Пример простого сервера и клиента с POST запросом](https://gist.github.com/umidjons/88fa0041e6dd583491dd83662d007d2c)

## Организация кода в Node.js

#### 5 основных правил структурирования проектов
Существует множество возможных способов организации Node.js-проектов и каждый из известных методов имеет свои плюсы и минусы. Однако разработчики всегда хотят добиться одного и того же: чистоты кода и возможности легко добавлять новые функции.

[5 основных правил структурирования проектов](https://medium.com/devschacht/node-hero-chapter-7-4078fa61ece6)

[Node.js app пример](https://github.com/contentful/the-example-app.nodejs) смотрите только те файлы и папки что вам нужны

## Nodemon, мониторинг изменений в файлах Node.js

Абсолютно у всех разработчиков знакомство с nodejs начинается с того, что после каждого изменения нужно перезагружать сервер. Поэтому, в этом видео мы разберем, как сделать так, чтобы сервер перегружался автоматически.

Самый популярный вариант - это nodemon. То есть идея состоит в том, что в development окружении мы хотим, чтобы nodemon следил за файлами, которые мы меняем и просто перезапускал сервер, если эти файлы относятся к серверу.

Для установки - `npm install -g nodemon`

[Видео по nodemon](https://monsterlessons.com/project/lessons/perezagruzhaem-node-s-pomoshyu-nodemon)


## Homework 1

Мы будем делать онлайн сервис по заказу еды (пица например). На бекенд курсе - делаем сервер, на react курсе - клиентское приложение.

В работе над заданиями проявляйте креативность, принимайте решение в мелочах как вам больше нравится. Подумайте над тем как по-вашему мнению должен работать такой интернет магазин. Это будет полностью ваш проект.

### Задание:
- Сделать основу бекенд приложения (по примеру в папочке demo)
- Создать `json` с товарами
  - Скачать этот `json` https://gist.github.com/burnjohn/961d8809f670be165cc5e31ded8eb358
  - Расширить по примеру еще 5мя блюдами
  - Сохранить `json` под названием `all-products.json` по адресу `src/db/products`

- Сделать роутинг

- В роутинге должны быть следующие пути:
    - GET `/products` в ответе должны прийти все товары (из `all-products.json`)
    - POST `/signup` 
       1. Вы отправляете данные нового юзера в формате

       ```
       {
        "username": "Ivan",
        "telephone": "063 777 77 77",
        "password": "12345",
        "email": "ivan@gmail.com"
       }
       ```

       2. На бекенде берете данные что вам пришли и сохраняете их в `<username>.json`, который кладете по адресу  `src/db/users`. (json нужно создать самим с помощью модуля fs)
       3. В ответ отправляете `json` 

       ```
       {
        "status": "success", 
        "user": {
           "username": "Ivan",
           "telephone": "063 777 77 77",
           "password": "12345",
           "email": "ivan@gmail.com"
         }
       }
       ```

#### Требования
   - Приложение должно лежать в отдельном вашем репозитории с названием `food-delivery-server-goit`
   - Все задание нужно делать в ветке `homework-1`
   - После того как закончите задание нужно сделать pull request в ветку `master`




