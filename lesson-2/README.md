# Lesson 2. Node js основы

- https, cors
- Архитектура REST. RESTful API
- Semver
- Объект global, глобальные переменные
- Работа с каталогами
- Работа с файлами

## HTTPS

HTTPS — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов SSL или TLS.

HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы SSL и TLS. Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения

В протоколе HTTPS используется асимметричная схема шифрования за счет использования гибридной системы TLS (усовершенствованный SSL). Во всей сложной системе в роли замка выступает как раз он.

Чтобы подготовить веб-сервер для обработки https-соединений, разработчик должен получить и установить в систему сертификат открытого ключа для этого веб-сервера. 

В TLS используется как асимметричная схема шифрования (в которой учавствуют 2 ключа), так и симметричная (для обмена данными, зашифрованными общим ключом). Сертификат публичного ключа (**public key**) посылается клиенту при установлении соединения; Приватный ключ (**private key**) используется для расшифровки сообщений от клиента.

[Что такое https, как получить бесплатный сертификат для статического сайта](https://www.youtube.com/watch?v=-G256iibFYg)
[Установка сертификата в node.js](https://www.youtube.com/watch?v=r92gqYHJc5c)

## CORS (Cross-Origin Resource Sharing)

Cross-Origin Resource Sharing (CORS) — механизм, использующий дополнительные HTTP-заголовки, чтобы дать возможность агенту пользователя получать разрешения на доступ к выбранным ресурсам с сервера на источнике (домене), отличном от того, что сайт использует в данный момент. Говорят, что агент пользователя делает запрос с другого источника (cross-origin HTTP request), если источник текущего документа отличается от запрашиваемого ресурса доменом, протоколом или портом.

Пример cross-origin запроса: HTML страница, обслуживаемая сервером с `http://domain-a.com`, запрашивает <img> src по адресу `http://domain-b.com/image.jpg`. Здесь у нас разные домены и в разрешении связей между ними учавствует CORS. 

Сегодня многие страницы загружают ресурсы вроде CSS-стилей, изображений и скриптов с разных доменов, соответствующих разным сетям доставки контента (Content delivery networks, CDNs).

В целях безопасности браузеры ограничивают cross-origin запросы, инициируемые скриптами. Например, `XMLHttpRequest` и `Fetch API` следуют политике одного источника (same-origin policy). Это значит, что web-приложения, использующие такие API, могут запрашивать HTTP-ресурсы только с того домена, с которого были загружены, пока не будут использованы CORS-заголовки.

[Больше о СORS](https://developer.mozilla.org/ru/docs/Web/HTTP/CORS)

[Настройка CORS на node js](https://www.youtube.com/watch?v=bo0Asv8L9Vg)


## Архитектура REST. RESTful API

REST — REpresentational State Transfer. Это передача/изменения состояния через представления. REST — это архитектурный стиль, некоторое множество ограничений, для построения распределенных приложений.

Архитектура REST описывается следующими ограничениями. 

- [Единый интерфейс (Uniform Interface)](http://www.restapitutorial.ru/lessons/whatisrest.html#uniform-interface)
- [Отсутствие состояний (Stateless)](http://www.restapitutorial.ru/lessons/whatisrest.html#stateless)
- [Кеширование ответа (Cacheable)](http://www.restapitutorial.ru/lessons/whatisrest.html#cacheable)
- [Клиент-сервер (Client-Server)](http://www.restapitutorial.ru/lessons/whatisrest.html#client-server)
- [Многоуровневая система (Layered System)](http://www.restapitutorial.ru/lessons/whatisrest.html#layered-system)

Чем больше ограничений вы выполните, тем более "full" получится приложение. В теории при выполнении всех требований вы получайте **RESTful** приложение, если соблюдать только часть из них это **REST-like**.

Ключевое понятие в REST — это ресурс. Ресурс имеет состояние, и мы можем его получать или изменять при помощи представлений. Наше приложение отвечает за некоторое множество таких ресурсов. Кстати, совокупное состояние ресурсов — это и есть состояние приложения.

Примеры ресурсов:

- Пользователи системы
- Курсы, в которых зарегистрирован студент
- История сообщений пользователя
- Пользователь
- Товар магазина
- Товары магазина
- Категория товаров магазина
- Категории товаров магазина

Чтобы создать нового покупателя в системе мы используем:

`POST http://www.example.com/customer`

Чтобы создать новый товар мы используем:

`POST http://www.example.com/product`

Для чтения, обновления, удаления продукта с id `66432`.

`GET|PUT|DELETE http://www.example.com/products/66432`

Чтобы получить информацию о товаре с id `12345` мы используем :

`GET http://www.example.com/product/12345`  

Тот же URI мы используем для PUT и DELETE, чтобы обновлять и удалять, соответственно.

Ниже предложен URI для получения всех продуктов:

`GET http://www.example.com/products`

Продуктов определенной категории:

`GET http://www.example.com/auto/products`


Каждый ресурс сервиса должен иметь хотя бы один URI, идентифицирующий его. И лучше всего, когда этот URI имеет смысл и адекватно описывает этот ресурс. URI должны иметь предсказуемую структуру.

Под представлением можно понимать JSON/HTML/XML/текст в определенном формате или что угодно, что позволяет нам понимать состояние ресурса или его модифицировать.

### Статьи
- [Именование ресурсов](http://www.restapitutorial.ru/lessons/restfulresourcenaming.html)
- [Понимание REST](https://dou.ua/lenta/articles/rest-conception/)


## SEMVER

Когда мы устанавливаем какой-то пакет, например, express, то в package.json добавляется последняя версия пакета, состоящая из трех цифр. Эти цифры означают Major, Minor, Patch и используют как спецификацию semver.

Что это значит? Когда я делаю пакет и еще не опубликовал его, то первая цифра идет 0. Это значит, что какие бы номера версий не шли дальше, я могу в любом момент менять любой функционал пакета. Потому что пакет, начинающийся с 0 - нестабильный пакет.

Когда мы опубликовали пакет, то каждый номер версии начинает иметь смысл. Последняя цифра - это PATCH. То есть внесение незначительных изменений в пакет, например bugfix.

Средняя цифра - это минорная версия. Она должна обновляться при изменениях, которые добавляют новый функционал, но не ломают то, что уже работает. Таким образом любой человек может обновится с 1.2.0 на 1.3.0 и все должно по прежнему работать.

Первая же цифра - это мажорная версия. Если внеслись хоть какие-то изменения, которые сломали текущий код, то должна релизится новая мажорная версия. Это может быть как изменение API, так и изменение порядка аргументов. Поэтому нужно делать версию 2.0.0.

Собственно вся система версий и пакетов подчиняется спецификации semver.

Мы можем указать, что пакет должен быть больше версии 1.2.7

`>= 1.2.7`

Тогда, при установке пакетов версия будет искаться только среди версий, которые больше 1.2.7.

Также можно указывать range.

`>=1.2.7 <1.3.0`

Также есть специальные пре релизные теги.

`1.2.3-alpha.3`
`1.2.3-beta.0`

Также часто встречаются тильда и каретка.

Когда у нас стоит тильда

`~1.2.3`
Это значит, что версия может меняться только от 1.2.3 до 1.3.0, то есть могут применятся только патчи, а минорная версия обновлятся не может.

Если же у нас стоит каретка

`^1.2.3`
То можно обновлять и минорную версию и накатывать патчи. То есть от 1.2.3 до 2.0.0.

[Видео с обьяснением](https://monsterlessons.com/project/lessons/razbiraemsya-s-versiyami-paketov-v-node)

## Объект global, глобальные переменные

Node.js предоставляет специальный объект `global`, который предоставляет доступ к глобальным, то есть доступным из каждого модуля приложения, переменным и функциям. 

Примерным аналогом данного объекта в javascript для браузера является объект `window`. Все доступные глобальные объекты можно посмотреть в [документации](https://nodejs.org/api/globals.html).

Примеры глобальных переменных:

- `__filename` указывает имя файла который в настоящее время выполняется. Абсолютный путь к месту где находится файл. 
- `__dirname` указывает адрес каталога где лежит файл что сейчас выполняется. Абсолютный путь к месту где находится каталог.
- `setInterval, setTimeout`
- `process`

[Документация на русском](http://www.w3big.com/ru/nodejs/nodejs-global-object.html)

Рекомендуется избегать определения и использования глобальных переменных, и преимущественно ориентироваться на создание переменных, инкапсулированных в рамках отдельных модулей.

[Статья с примером](https://metanit.com/web/nodejs/2.3.php)

## Работа с каталогами

В Node JS есть модуль отвечающий за работу с директориями и файлами. Он называется fs (file system).

#### Проверить существует ли директория 

`fs.existsSync(path)`

ВАЖНО! `fs.exists(path,cb)` deprecated, по этому нужно использовать только его синхронный аналог.


#### Создание директории

`fs.mkdir(path[, mode], callback);`

- `path` — это имя директории, включая путь к ней.
- `mode` – это права доступа к директории. По умолчанию — 0777.
- `callback` — это функция обратного вызова. Никакие аргументы кроме возможных исключений не передаются функции обратного вызова завершения.

Пример

```
var fs = require("fs");
 
console.log("Going to create directory /tmp/test");
fs.mkdir('/tmp/test',function(err){
   if (err) {
      return console.error(err);
   }
   console.log("Directory created successfully!");
});
```

#### Чтение директории

`fs.readdir(path, callback);`

Пример
```
var fs = require("fs");
 
console.log("Going to read directory /tmp");
fs.readdir("/tmp/",function(err, files){
   if (err) {
      return console.error(err);
   }
   files.forEach( function (file){
      console.log( file );
   });
});
```

#### Удаление директории

`fs.rmdir(path, callback)`

Пример

```
var fs = require("fs");
 
console.log("Going to delete directory /tmp/test");
fs.rmdir("/tmp/test",function(err){
   if (err) {
      return console.error(err);
   }
   console.log("Going to read directory /tmp");
   
   fs.readdir("/tmp/",function(err, files){
      if (err) {
         return console.error(err);
      }
      files.forEach( function (file){
         console.log( file );
      });
   });
});
```

[Видое о работе с директориями](https://www.youtube.com/watch?v=GlsyhBFfrgg)

## Работа с файлами

Пример чтения файла

```
var fs = require("fs");
 
// Asynchronous read
fs.readFile('input.txt', function (err, data) {
   if (err) {
      return console.error(err);
   }
   console.log("Asynchronous read: " + data.toString());
});
 
// Synchronous read
var data = fs.readFileSync('input.txt');
console.log("Synchronous read: " + data.toString());
 
console.log("Program Ended");
```

### Флаги для операций чтения/записи :

`r `— Открыть файл для чтения. Если файл не существует, добавляется исключение.

`г+` — Открыть файл для чтения и записи. Если файл не существует, добавляется исключение.

`rs `— Открыть файл для чтения в синхронном режиме.

`rs+` — Открыть файл для чтения и записи, запросив у ОС открыть его в синхронном режиме.

`w `— Открыть файл для записи. Файл создается (если он не существует) или усекается (если он существует).

`wx `— Работает так же как «w», но не выполняется, если путь существует.

`w+` — Открыть файл для чтения и записи. Если файл не существует, он создается, если файл существует, он усекается.

`wx+` — Работает так же как «w+», но не выполняется, если путь существует.

`a `— Открыть файл для дополнения. Если файл не существует, он создается.

`ax `— Работает как «а», но не выполняется, если путь существует.

`a+` — Открыть файл для чтения и расширения. Если файл не существует, он создается.

`ах`+ — Работает так же как «a+», но не выполняется, если путь существует.


#### Пример

```
// fs_write.js

const fs = require('fs');

// Путь к файлу который мы хотим изменить
let path = 'ghetto_gospel.txt';  
let buffer = new Buffer('Those who wish to follow me\nI welcome with my hands\nAnd the red sun sinks at last');

// открыть файл в режиме записи, добавить коллбек в котором сделать запись в файл
fs.open(path, 'w', function(err, fd) {  
    if (err) {
        throw 'could not open file: ' + err;
    }

    // записать контент в буфер с позиции 0 до конца 
    fs.write(fd, buffer, 0, buffer.length, null, function(err) {
        if (err) throw 'error writing file: ' + err;
        
        // Завершить изменение файла
        fs.close(fd, function() {
            console.log('wrote the file successfully');
        });
    });
```

Для перезаписи файла можно использовать более простой метод `fs.writeFile()`

[Статья "Как писать данные в файлы"](https://stackabuse.com/writing-to-files-in-node-js/)

```
var fs = require('fs');

fs.writeFile('mynewfile3.txt', 'This is my text', function (err) {
  if (err) throw err;
  console.log('Replaced!');
});
```

#### Запись файла
`fs.writeFile(filename, data[, options], callback)`

Этот метод перезаписывает файл, если файл уже существует. Если вы хотите дописать что-то в существующий файл, вы должны использовать другой доступный метод.

###  Переименовать файл

`fs.rename(new_file_path, old_file_path, callback_function)`

#### Удаление файла

`fs.unlink(path, callback)`

```
var fs = require("fs");
 
console.log("Going to delete an existing file");
fs.unlink('input.txt', function(err) {
   if (err) {
      return console.error(err);
   }
   console.log("File deleted successfully!");
});
```

#### Получение информации о файлах

`fs.stat(path, callback)`

Чаще всего используемы только эти 2 метода:

`stats.isFile()` — Возвращает true, если тип файла — простой файл.

`stats.isDirectory()` — Возвращает true, если тип файла — каталог.


[Статья о работе с файлами и директориями](https://webformyself.com/node-js-fs-fajlovaya-sistema/)

### Задание:

Это должен быть второй пул реквест в ваш репозиторий с домашним заданием.
За основу нужно взять проект из домашнего задания 1.

В рамках нашего приложения `food-delivery` вам нужно будет сделать следующие задания

1. Возможность получить данные какого-либо продукта по `id`

На сервер приходит `GET localhost:3001/products/12345` 
Ищете товар по `id` в `all-products.json`
Отправляете пользователю ответ в виде:

```json

{
 "status": "success", 
 "products": [{
    "id": 1234,
    "sku": 1120001,
    "name": "Пицца Пепперони с томатами",
    "description": "Пицца пепперони - очень популярный вид пиццы как в Европе, так и в Америке. Она получила свое название благодаря основному ингредиенту солями пепперони, который и отличает ее от всех остальных видов пицц. Он имеет острый вкус и при запекании покрывается хрустящей жирной корочкой.",
    "price": "100",
    "currency": "UAN",
    "creatorId": 1,
    "created": "21-08-2018",
    "modified": "21-08-2018",
    "categories": ["pizza"]
  }]
}

```

2. Возможность получить данные нескольких продуктов по `id`шкам

На сервер приходит `GET localhost:3001/products/?ids='<id>, <id>,<id>'` 
Ищете товары по `id` в `all-products.json`
Отправляете пользователю ответ в виде:

```json

{
 "status": "success", 
 "products": [
    {
      "id": 1234,
      "sku": 1120001,
      "name": "Пицца Пепперони с томатами",
      "description": "Пицца пепперони - очень популярный вид пиццы как в Европе, так и в Америке. Она получила свое название благодаря основному ингредиенту солями пепперони, который и отличает ее от всех остальных видов пицц. Он имеет острый вкус и при запекании покрывается хрустящей жирной корочкой.",
    },
    {
      "id": 1234,
      "sku": 1120001,
      "name": "Другая пица",
      "description": "Some text"
    },
  ]
}
```

3. Возможность получить данные нескольких продуктов по категориям

- На сервер приходит `GET localhost:3001/products/?category="drinks"` 
- Ищете товары по `id` в `all-products.json`
- Отправляете пользователю ответ в таком же виде как и в ответе выше.


Если в `all-products.json` нет товаров что вы ищите то ответ должен быть:

```json

{
 "status": "no products", 
 "products": []
}
```
  4. Сделать на сервере поддержку `https`
  
  #### `https`
  - Сгенерировать ключ и сертификат [инструкция](https://devcenter.heroku.com/articles/ssl-certificate-self)
  - Подключить `https` модуль, передать в него ключи
  - Убедится что когда вы заходите на localhost вашего бекенд приложения браузер говорит что `connection is secure`` 
  
  
#### Требования
   - Приложение должно лежать в отдельном вашем репозитории с названием `marketplace-server-goit`
   - Все задание нужно делать в ветке `homework-2`
   - После того как закончите задание нужно сделать pull request в ветку `master`
